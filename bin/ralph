#!/bin/bash
# Ralph v2 — Autonomous Implementation Loop
# Usage: ralph <command> [options]
set -euo pipefail

# ── Resolve RALPH_DIR (the ralph installation directory) ────────────────────
RALPH_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")/.." && pwd)"
export RALPH_DIR

# ── Source core libraries ───────────────────────────────────────────────────
source "${RALPH_DIR}/lib/ui.sh"
source "${RALPH_DIR}/lib/prereqs.sh"

# ── Version ─────────────────────────────────────────────────────────────────
RALPH_VERSION="2.0.0"

# ── Usage ───────────────────────────────────────────────────────────────────
usage() {
    echo "Ralph v${RALPH_VERSION} — Autonomous Implementation Loop"
    echo ""
    echo "Usage: ralph <command> [options]"
    echo ""
    echo "Commands:"
    echo "  init                  Initialize Ralph in current project"
    echo "  run [options]         Run the implementation loop"
    echo "  status                Show current progress"
    echo "  stories               List all stories and their status"
    echo "  learnings [topic]     Show extracted learnings"
    echo "  reset                 Reset state (completed stories, retries)"
    echo ""
    echo "Run Options:"
    echo "  -n, --iterations NUM  Number of iterations (0 = until done)"
    echo "  -s, --story ID        Run a specific story only"
    echo "  -r, --resume ID       Resume from a specific story"
    echo "  -v, --verbose         Show full Claude output"
    echo "  -d, --dry-run         Preview prompt without executing"
    echo "  -t, --timeout SECS    Timeout per iteration (default: 1800)"
    echo "  --parallel            Enable parallel execution"
    echo "  --no-tmux             Don't auto-wrap in tmux"
    echo "  --no-interactive      Skip interactive startup prompts"
    echo ""
    echo "Examples:"
    echo "  ralph init"
    echo "  ralph run"
    echo "  ralph run -s 3.4"
    echo "  ralph run -n 5 -v"
    echo "  ralph run --parallel"
    echo "  ralph status"
    exit 0
}

# ── Subcommand: init ────────────────────────────────────────────────────────
cmd_init() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/interactive.sh"

    log_info "Initializing Ralph in $(pwd)"

    if [[ -f ".ralph/config.json" ]]; then
        log_warn "Ralph already initialized in this project."
        read -rp "Reinitialize? This will overwrite config.json. [y/N] " confirm
        [[ "$confirm" != [yY] ]] && exit 0
    fi

    interactive_init

    log_success "Ralph initialized. Edit .ralph/stories.txt to add your stories."
    log_info "Then run: ralph run"
}

# ── Subcommand: run ─────────────────────────────────────────────────────────
cmd_run() {
    # Source all required libraries
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"
    source "${RALPH_DIR}/lib/specs.sh"
    source "${RALPH_DIR}/lib/prompt.sh"
    source "${RALPH_DIR}/lib/signals.sh"
    source "${RALPH_DIR}/lib/hooks.sh"
    source "${RALPH_DIR}/lib/caffeine.sh"
    source "${RALPH_DIR}/lib/tmux.sh"

    # Optional modules
    [[ -f "${RALPH_DIR}/lib/learnings.sh" ]] && source "${RALPH_DIR}/lib/learnings.sh"
    [[ -f "${RALPH_DIR}/lib/testing.sh" ]] && source "${RALPH_DIR}/lib/testing.sh"
    [[ -f "${RALPH_DIR}/lib/parallel.sh" ]] && source "${RALPH_DIR}/lib/parallel.sh"
    [[ -f "${RALPH_DIR}/lib/interactive.sh" ]] && source "${RALPH_DIR}/lib/interactive.sh"

    # Check prerequisites
    prereqs_check || exit 1
    prereqs_check_project || exit 1

    # Load config
    config_load || exit 1

    # Parse run-specific flags
    local iterations verbose dry_run specific_story resume_from timeout_secs
    local use_parallel=false no_tmux=false no_interactive=false

    iterations=$(config_get '.loop.max_iterations' '0')
    timeout_secs=$(config_get '.loop.timeout_seconds' '1800')
    verbose=false
    dry_run=false
    specific_story=""
    resume_from=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -n|--iterations)   iterations="$2"; shift 2 ;;
            -s|--story)        specific_story="$2"; shift 2 ;;
            -r|--resume)       resume_from="$2"; shift 2 ;;
            -v|--verbose)      verbose=true; shift ;;
            -d|--dry-run)      dry_run=true; shift ;;
            -t|--timeout)      timeout_secs="$2"; shift 2 ;;
            --parallel)        use_parallel=true; shift ;;
            --no-tmux)         no_tmux=true; shift ;;
            --no-interactive)  no_interactive=true; shift ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    RALPH_VERBOSE="$verbose"
    export RALPH_VERBOSE

    # Interactive startup (if no flags override and not disabled)
    if [[ "$no_interactive" == false && -z "$specific_story" && "$dry_run" == false ]]; then
        if type interactive_run_prompt &>/dev/null; then
            interactive_run_prompt
            # interactive_run_prompt may set: RALPH_RUN_ITERATIONS, RALPH_RUN_VERBOSE, etc.
            [[ -n "${RALPH_RUN_ITERATIONS:-}" ]] && iterations="$RALPH_RUN_ITERATIONS"
            [[ -n "${RALPH_RUN_VERBOSE:-}" ]] && verbose="$RALPH_RUN_VERBOSE"
            [[ -n "${RALPH_RUN_TIMEOUT:-}" ]] && timeout_secs="$RALPH_RUN_TIMEOUT"
            [[ -n "${RALPH_RUN_STORY:-}" ]] && specific_story="$RALPH_RUN_STORY"
            [[ -n "${RALPH_RUN_CAFFEINE:-}" ]] && caffeine_requested="$RALPH_RUN_CAFFEINE"
        fi
    fi

    # Auto tmux
    if [[ "$no_tmux" == false ]]; then
        tmux_ensure
    fi

    # Caffeine
    if [[ "$(config_get '.caffeine' 'false')" == "true" || "${caffeine_requested:-}" == "true" ]]; then
        caffeine_start
        trap caffeine_stop EXIT
    fi

    # Initialize state
    state_init

    # Parallel mode
    if [[ "$use_parallel" == true || "$(config_get '.parallel.enabled' 'false')" == "true" ]]; then
        if type parallel_run &>/dev/null; then
            parallel_run "$timeout_secs" "$verbose" "$dry_run"
            return $?
        else
            log_warn "Parallel module not available. Running sequentially."
        fi
    fi

    # Sequential execution loop
    _run_sequential "$iterations" "$timeout_secs" "$verbose" "$dry_run" "$specific_story" "$resume_from"
}

_run_sequential() {
    local iterations="$1"
    local timeout_secs="$2"
    local verbose="$3"
    local dry_run="$4"
    local specific_story="$5"
    local resume_from="$6"

    local total_stories
    total_stories=$(stories_count_total)
    local done_count
    done_count=$(state_completed_count)

    box_header "RALPH IMPLEMENTATION LOOP"
    box_kv "Project" "$(config_get '.project.name' '(unnamed)')"
    box_kv "Stories" "$done_count / $total_stories completed"
    box_kv "Iterations" "$( [[ "$iterations" == "0" ]] && echo "unlimited" || echo "$iterations" )"
    box_kv "Timeout" "${timeout_secs}s per story"
    [[ -n "$specific_story" ]] && box_kv "Story" "$specific_story (specific)"
    [[ -n "$resume_from" ]] && box_kv "Resume" "from $resume_from"
    echo ""

    log "Ralph loop starting"

    local max_retries
    max_retries=$(config_get '.loop.max_retries' '3')

    local timeout_cmd
    timeout_cmd=$(prereqs_timeout_cmd)

    local iteration=0
    while true; do
        iteration=$((iteration + 1))

        # Check iteration limit
        if [[ "$iterations" != "0" && $iteration -gt $iterations ]]; then
            box_header "Reached iteration limit ($iterations)"
            break
        fi

        iteration_header "$iteration" "$( [[ "$iterations" == "0" ]] && echo "inf" || echo "$iterations" )"

        # Find next story
        local next_story
        if [[ -n "$specific_story" ]]; then
            next_story="$specific_story"
        elif ! next_story=$(stories_find_next "$resume_from"); then
            box_header "ALL STORIES COMPLETE!"
            log "All stories complete — Ralph loop finished"
            return 0
        fi
        # Clear resume after first use
        resume_from=""

        # Find spec file
        local spec_path
        if ! spec_path=$(spec_find "$next_story"); then
            log_error "Could not find spec for story $next_story"
            continue
        fi

        local title
        title=$(stories_get_title "$next_story" 2>/dev/null || spec_get_title "$spec_path")

        log "Starting story $next_story: $title"
        echo "  Story:  $next_story — $title"
        echo "  Spec:   $spec_path"

        # Build prompt
        local prompt
        prompt=$(prompt_build "$next_story" "$spec_path") || continue

        # Dry run mode
        if [[ "$dry_run" == true ]]; then
            echo ""
            echo "[DRY RUN] Rendered prompt (first 30 lines):"
            divider
            echo "$prompt" | head -30
            echo "..."
            divider
            [[ -n "$specific_story" ]] && return 0
            continue
        fi

        # Run hooks
        hooks_run "pre_story" "RALPH_STORY=$next_story" "RALPH_SPEC=$spec_path"

        # Update state
        state_set_current "$next_story"

        # Build claude command
        local claude_flags=()
        while IFS= read -r flag; do
            [[ -n "$flag" ]] && claude_flags+=("$flag")
        done < <(config_get_claude_flags)

        local result exit_code=0

        if [[ "$verbose" == true ]]; then
            result=$($timeout_cmd "$timeout_secs" claude "${claude_flags[@]}" "$prompt" 2>&1 | tee /dev/stderr) || exit_code=$?
        else
            result=$($timeout_cmd "$timeout_secs" claude "${claude_flags[@]}" "$prompt" 2>&1) || exit_code=$?
        fi

        # Handle timeout
        if [[ $exit_code -eq 124 ]]; then
            log_warn "Story $next_story timed out after ${timeout_secs}s"
            _handle_failure "$next_story" "Timeout after ${timeout_secs}s" "$spec_path" "$max_retries"
            hooks_run "post_story" "RALPH_STORY=$next_story" "RALPH_RESULT=timeout"
            continue
        fi

        # Handle other errors
        if [[ $exit_code -ne 0 ]]; then
            log_error "Story $next_story failed (exit code: $exit_code)"
            _handle_failure "$next_story" "Exit code $exit_code" "$spec_path" "$max_retries"
            hooks_run "post_story" "RALPH_STORY=$next_story" "RALPH_RESULT=error"
            continue
        fi

        # Extract learnings
        if type learnings_extract &>/dev/null; then
            learnings_extract "$result" "$next_story"
        fi

        # Parse signals
        local done_id
        if done_id=$(signals_parse_done "$result"); then
            if [[ "$done_id" == "$next_story" ]]; then
                log_success "Story $next_story completed!"
                state_mark_done "$next_story"
                spec_update_status "$spec_path" "done"

                # Append to progress.txt
                local timestamp
                timestamp=$(date '+%a %d %b %Y %H:%M:%S %Z')
                echo "[DONE] Story $next_story - $title - $timestamp" >> progress.txt

                # Testing specialist phase
                if [[ "$(config_get '.testing_phase.enabled' 'false')" == "true" ]]; then
                    if type testing_review &>/dev/null; then
                        testing_review "$next_story" "$spec_path"
                    fi
                fi

                hooks_run "post_story" "RALPH_STORY=$next_story" "RALPH_RESULT=done"

                [[ -n "$specific_story" ]] && return 0
            else
                log_warn "DONE signal for $done_id but expected $next_story"
                _handle_failure "$next_story" "Mismatched DONE signal" "$spec_path" "$max_retries"
            fi
        elif fail_info=$(signals_parse_fail "$result"); then
            local fail_id="${fail_info%%|*}"
            local fail_reason="${fail_info#*|}"
            log_error "Story $fail_id failed: $fail_reason"
            _handle_failure "$next_story" "$fail_reason" "$spec_path" "$max_retries"
            hooks_run "post_story" "RALPH_STORY=$next_story" "RALPH_RESULT=fail"
        else
            log_warn "No completion signal found"
            _handle_failure "$next_story" "No completion signal in output" "$spec_path" "$max_retries"
            hooks_run "post_story" "RALPH_STORY=$next_story" "RALPH_RESULT=no_signal"
        fi

        hooks_run "post_iteration" "RALPH_ITERATION=$iteration"
    done
}

_handle_failure() {
    local story="$1"
    local reason="$2"
    local spec_path="$3"
    local max_retries="$4"

    state_increment_retry "$story"
    local retry_count
    retry_count=$(state_get_retry_count)

    local timestamp
    timestamp=$(date '+%a %d %b %Y %H:%M:%S %Z')
    echo "[FAIL] Story $story - $reason - $timestamp (attempt $retry_count/$max_retries)" >> progress.txt

    log "Story $story failed (attempt $retry_count/$max_retries): $reason"

    if [[ $retry_count -ge $max_retries ]]; then
        box_header "MAX RETRIES EXCEEDED"
        echo "  Story $story failed $max_retries times."
        echo "  Human intervention required."
        echo ""
        echo "  Last failure: $reason"
        echo ""
        echo "  To retry: ralph run -s $story"
        log "EXITING: Story $story exceeded max retries ($max_retries)"
        exit 1
    fi
}

# ── Subcommand: status ──────────────────────────────────────────────────────
cmd_status() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    local total done_count remaining current
    total=$(stories_count_total)
    done_count=$(state_completed_count)
    remaining=$(stories_count_remaining)
    current=$(state_get_current)

    box_header "RALPH STATUS"
    box_kv "Project" "$(config_get '.project.name' '(unnamed)')"
    box_kv "Progress" "$done_count / $total stories ($remaining remaining)"
    [[ -n "$current" ]] && box_kv "Current" "Story $current"
    box_kv "Retry count" "$(state_get_retry_count)"

    # Show next story
    local next
    if next=$(stories_find_next); then
        box_kv "Next" "Story $next"
    else
        echo ""
        log_success "All stories complete!"
    fi
    echo ""
}

# ── Subcommand: stories ────────────────────────────────────────────────────
cmd_stories() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    echo ""
    echo "Stories:"
    divider

    while IFS= read -r line; do
        local id
        id=$(echo "$line" | sed 's/|.*//' | xargs)
        local title
        title=$(echo "$line" | sed 's/^[^|]*|[[:space:]]*//')

        if state_is_completed "$id"; then
            echo -e "  ${CLR_GREEN}[done]${CLR_RESET}  $id | $title"
        elif [[ "$id" == "$(state_get_current)" ]]; then
            echo -e "  ${CLR_YELLOW}[curr]${CLR_RESET}  $id | $title"
        else
            echo -e "  ${CLR_DIM}[    ]${CLR_RESET}  $id | $title"
        fi
    done < <(stories_list_details)

    echo ""
}

# ── Subcommand: learnings ──────────────────────────────────────────────────
cmd_learnings() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/learnings.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    local topic="${1:-}"
    learnings_show "$topic"
}

# ── Subcommand: reset ──────────────────────────────────────────────────────
cmd_reset() {
    source "${RALPH_DIR}/lib/state.sh"

    if [[ ! -f "$RALPH_STATE_FILE" ]]; then
        log_error "No state file found."
        exit 1
    fi

    echo "This will reset:"
    echo "  - Completed stories list"
    echo "  - Current story tracking"
    echo "  - Retry count"
    echo ""
    read -rp "Are you sure? [y/N] " confirm
    [[ "$confirm" != [yY] ]] && exit 0

    _state_write_empty
    log_success "State reset."
}

# ── Dispatch ────────────────────────────────────────────────────────────────
case "${1:-}" in
    init)      shift; cmd_init "$@" ;;
    run)       shift; cmd_run "$@" ;;
    status)    shift; cmd_status "$@" ;;
    stories)   shift; cmd_stories "$@" ;;
    learnings) shift; cmd_learnings "$@" ;;
    reset)     shift; cmd_reset "$@" ;;
    version|-V|--version) echo "Ralph v${RALPH_VERSION}" ;;
    help|-h|--help|"") usage ;;
    *)
        log_error "Unknown command: $1"
        usage
        ;;
esac
