#!/usr/bin/env bash
# Ralphetamine — Autonomous Implementation Loop
# Usage: ralph <command> [options]

# ── Ensure Bash 4+ ────────────────────────────────────────────────────────────
# macOS ships Bash 3.2 at /bin/bash. Ralph requires Bash 4+ for regex
# captures (BASH_REMATCH), arrays, and parallel execution. If the current
# shell is too old, find a newer one and re-exec transparently.
if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
    for _ralph_bash in /opt/homebrew/bin/bash /usr/local/bin/bash; do
        if [[ -x "$_ralph_bash" ]] && "$_ralph_bash" -c '[[ "${BASH_VERSINFO[0]}" -ge 4 ]]' 2>/dev/null; then
            exec "$_ralph_bash" "${BASH_SOURCE[0]}" "$@"
        fi
    done
    echo "[ERROR] Ralph requires Bash 4.0+. Current: ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}" >&2
    echo "[ERROR] On macOS: brew install bash" >&2
    exit 1
fi

set -Eeuo pipefail

# ── Resolve RALPH_DIR (the ralph installation directory) ────────────────────
# Portable symlink resolution — macOS BSD readlink lacks -f
_ralph_resolve_path() {
    local path="$1"
    while [[ -L "$path" ]]; do
        local dir
        dir=$(cd "$(dirname "$path")" && pwd)
        path=$(readlink "$path")
        # Handle relative symlinks
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$path"
}
RALPH_DIR="$(cd "$(dirname "$(_ralph_resolve_path "${BASH_SOURCE[0]}")")/.." && pwd)"
export RALPH_DIR

# ── Source core libraries ───────────────────────────────────────────────────
source "${RALPH_DIR}/lib/ui.sh"
source "${RALPH_DIR}/lib/prereqs.sh"

# ── Version ─────────────────────────────────────────────────────────────────
RALPH_VERSION="2.4.0"

# ── Usage ───────────────────────────────────────────────────────────────────
usage() {
    echo "Ralphetamine v${RALPH_VERSION} — Autonomous Implementation Loop"
    echo ""
    echo "Usage: ralph <command> [options]"
    echo ""
    echo "Commands:"
    echo "  init                  Initialize Ralph in current project"
    echo "  run [options]         Run the implementation loop"
    echo "  reconcile [--apply]   Find/merge orphaned story branches"
    echo "  status                Show current progress"
    echo "  stats [options]       Show run statistics and token usage"
    echo "  stories               List all stories and their status"
    echo "  verify                Verify PRD-to-spec provenance integrity"
    echo "  hitl [generate|feedback] Generate HITL review page or feedback PRD"
    echo "  decompose <story-id>  Manually decompose a story into sub-stories"
    echo "  learnings [topic]     Show extracted learnings"
    echo "  reset                 Reset state (completed stories, retries)"
    echo ""
    echo "Run Options:"
    echo "  -n, --iterations NUM  Number of iterations (0 = until done)"
    echo "  -s, --story ID        Run a specific story only"
    echo "  -r, --resume ID       Resume from a specific story"
    echo "  -v, --verbose         Show full Claude output"
    echo "  -d, --dry-run         Preview prompt without executing"
    echo "  -t, --timeout SECS    Timeout per iteration (default: 1800)"
    echo "  --parallel            Enable parallel execution"
    echo "  --no-dashboard        Disable live dashboard panel"
    echo "  --tmux                Wrap in tmux session"
    echo "  --no-tmux             (no-op, kept for backwards compatibility)"
    echo "  --no-interactive      Skip interactive startup prompts"
    echo ""
    echo "Stats Options:"
    echo "  --last N              Show last N runs"
    echo "  --story ID            Show stats for a specific story across runs"
    echo ""
    echo "Examples:"
    echo "  ralph init"
    echo "  ralph run"
    echo "  ralph run -s 3.4"
    echo "  ralph run -n 5 -v"
    echo "  ralph run --parallel"
    echo "  ralph status"
    echo "  ralph stats"
    echo "  ralph stats --last 3"
    echo "  ralph stats --story 29.1"
    exit 0
}

# ── Subcommand: init ────────────────────────────────────────────────────────
cmd_init() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/provenance.sh"
    source "${RALPH_DIR}/lib/interactive.sh"

    log_info "Initializing Ralph in $(pwd)"

    if [[ -f ".ralph/config.json" ]]; then
        log_warn "Ralph already initialized in this project."
        read -rp "Reinitialize? This will overwrite config.json. [y/N] " confirm
        [[ "$confirm" != [yY] ]] && exit 0
    fi

    interactive_init

    log_success "Ralph initialized. Edit .ralph/stories.txt to add your stories."
    log_info "Then run: ralph run"
    echo ""
    log_warn "Security note: Ralph runs Claude with --dangerously-skip-permissions by default."
    log_warn "This grants Claude unrestricted system access during story execution."
    log_warn "Review .ralph/config.json 'claude.flags' to customize."
}

# ── Subcommand: run ─────────────────────────────────────────────────────────
cmd_run() {
    # Source all required libraries
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"
    source "${RALPH_DIR}/lib/specs.sh"
    source "${RALPH_DIR}/lib/prompt.sh"
    source "${RALPH_DIR}/lib/signals.sh"
    source "${RALPH_DIR}/lib/hooks.sh"
    source "${RALPH_DIR}/lib/caffeine.sh"
    source "${RALPH_DIR}/lib/tmux.sh"
    source "${RALPH_DIR}/lib/runner.sh"
    source "${RALPH_DIR}/lib/provenance.sh"

    # Optional modules
    [[ -f "${RALPH_DIR}/lib/learnings.sh" ]] && source "${RALPH_DIR}/lib/learnings.sh"
    [[ -f "${RALPH_DIR}/lib/testing.sh" ]] && source "${RALPH_DIR}/lib/testing.sh"
    [[ -f "${RALPH_DIR}/lib/parallel.sh" ]] && source "${RALPH_DIR}/lib/parallel.sh"
    [[ -f "${RALPH_DIR}/lib/interactive.sh" ]] && source "${RALPH_DIR}/lib/interactive.sh"
    [[ -f "${RALPH_DIR}/lib/display.sh" ]] && source "${RALPH_DIR}/lib/display.sh"
    [[ -f "${RALPH_DIR}/lib/hitl.sh" ]] && source "${RALPH_DIR}/lib/hitl.sh"
    [[ -f "${RALPH_DIR}/lib/metrics.sh" ]] && source "${RALPH_DIR}/lib/metrics.sh"
    [[ -f "${RALPH_DIR}/lib/decompose.sh" ]] && source "${RALPH_DIR}/lib/decompose.sh"
    [[ -f "${RALPH_DIR}/lib/mcp.sh" ]] && source "${RALPH_DIR}/lib/mcp.sh"

    # Check prerequisites
    prereqs_check || exit 1
    prereqs_check_project || exit 1

    # Load config
    config_load || exit 1

    # Save original args before parsing consumes them (needed for tmux re-exec)
    local original_args=()
    [[ $# -gt 0 ]] && original_args=("$@")

    # Parse run-specific flags
    local iterations verbose dry_run specific_story resume_from timeout_secs
    local use_parallel=false use_tmux=false no_interactive=false no_dashboard=false

    iterations=$(config_get '.loop.max_iterations' '0')
    timeout_secs=$(config_get '.loop.timeout_seconds' '1800')
    verbose=false
    dry_run=false
    specific_story=""
    resume_from=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -n|--iterations)   iterations="$2"; shift 2 ;;
            -s|--story)        specific_story="$2"; shift 2 ;;
            -r|--resume)       resume_from="$2"; shift 2 ;;
            -v|--verbose)      verbose=true; shift ;;
            -d|--dry-run)      dry_run=true; shift ;;
            -t|--timeout)      timeout_secs="$2"; shift 2 ;;
            --parallel)        use_parallel=true; shift ;;
            --no-dashboard)    no_dashboard=true; shift ;;
            --tmux)            use_tmux=true; shift ;;
            --no-tmux)         shift ;;  # backwards compat (tmux already off by default)
            --no-interactive)  no_interactive=true; shift ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    export RALPH_VERBOSE="$verbose"

    # Tmux wrapper (opt-in) — must happen before interactive prompt so user is only prompted once
    if [[ "$use_tmux" == true ]]; then
        tmux_ensure run "${original_args[@]+"${original_args[@]}"}"
    fi

    # Interactive startup (if no flags override and not disabled)
    if [[ "$no_interactive" == false && -z "$specific_story" && "$dry_run" == false ]]; then
        if type interactive_run_prompt &>/dev/null; then
            interactive_run_prompt
            # interactive_run_prompt may set: RALPH_RUN_ITERATIONS, RALPH_RUN_VERBOSE, etc.
            [[ -n "${RALPH_RUN_ITERATIONS:-}" ]] && iterations="$RALPH_RUN_ITERATIONS"
            [[ -n "${RALPH_RUN_VERBOSE:-}" ]] && verbose="$RALPH_RUN_VERBOSE"
            [[ -n "${RALPH_RUN_TIMEOUT:-}" ]] && timeout_secs="$RALPH_RUN_TIMEOUT"
            [[ -n "${RALPH_RUN_STORY:-}" ]] && specific_story="$RALPH_RUN_STORY"
            [[ -n "${RALPH_RUN_CAFFEINE:-}" ]] && caffeine_requested="$RALPH_RUN_CAFFEINE"
            # Check dry-run flag from interactive mode (#7)
            [[ "${RALPH_RUN_DRY_RUN:-}" == "true" ]] && dry_run=true
        fi
    fi

    # Re-export after interactive may have changed verbose
    export RALPH_VERBOSE="$verbose"

    # Dashboard control
    if [[ "$no_dashboard" == true ]]; then
        export RALPH_DASHBOARD="false"
    fi

    # Caffeine (uses centralized trap registry from ui.sh)
    if [[ "$(config_get '.caffeine' 'false')" == "true" || "${caffeine_requested:-}" == "true" ]]; then
        caffeine_start
        ralph_on_exit caffeine_stop
    fi

    # MCP browser lifecycle — start before state_init so run manifest is written early
    # Export parallel mode so mcp_browser_start can populate the manifest correctly
    if [[ "$use_parallel" == true || "$(config_get '.parallel.enabled' 'false')" == "true" ]]; then
        export _RALPH_PARALLEL_MODE="true"
    fi
    if type mcp_browser_enabled &>/dev/null && mcp_browser_enabled 2>/dev/null; then
        mcp_browser_start || { log_error "MCP browser start failed. Aborting."; exit 1; }
        ralph_on_exit mcp_browser_stop
    fi

    # Initialize state
    state_init

    # Acquire run lock (prevents concurrent instances)
    _acquire_run_lock || exit 1
    ralph_on_exit _release_run_lock

    # Parallel mode
    if [[ "$use_parallel" == true || "$(config_get '.parallel.enabled' 'false')" == "true" ]]; then
        if type parallel_run &>/dev/null; then
            parallel_run "$timeout_secs" "$verbose" "$dry_run"
            return $?
        else
            log_warn "Parallel module not available. Running sequentially."
        fi
    fi

    # Sequential execution loop
    _run_sequential "$iterations" "$timeout_secs" "$verbose" "$dry_run" "$specific_story" "$resume_from"
}

# _run_sequential and _handle_failure are now in lib/runner.sh

# ── Subcommand: status ──────────────────────────────────────────────────────
cmd_status() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    local total done_count remaining current
    total=$(stories_count_total)
    done_count=$(stories_count_completed)
    remaining=$(stories_count_remaining)
    current=$(state_get_current)

    box_header "RALPH STATUS"
    box_kv "Project" "$(config_get '.project.name' '(unnamed)')"
    box_kv "Progress" "$done_count / $total stories ($remaining remaining)"
    [[ -n "$current" ]] && box_kv "Current" "Story $current"
    box_kv "Retry count" "$(state_get_retry_count)"

    # Show next story
    local next
    if next=$(stories_find_next); then
        box_kv "Next" "Story $next"
    else
        echo ""
        log_success "All stories complete!"
    fi
    echo ""
}

# ── Subcommand: stats ──────────────────────────────────────────────────────
cmd_stats() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/metrics.sh"

    prereqs_check_project || exit 1

    local last_n=0
    local story_id=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --last)     last_n="$2"; shift 2 ;;
            --story)    story_id="$2"; shift 2 ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done

    if [[ -n "$story_id" ]]; then
        metrics_show_story "$story_id"
    else
        metrics_show "$last_n"
    fi
}

# ── Subcommand: stories ────────────────────────────────────────────────────
cmd_stories() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    echo ""
    echo "Stories:"
    divider

    while IFS= read -r line; do
        local id
        id=$(echo "$line" | sed 's/|.*//' | xargs)
        local title
        title=$(echo "$line" | sed 's/^[^|]*|[[:space:]]*//')

        if state_is_completed "$id"; then
            echo -e "  ${CLR_GREEN}[done]${CLR_RESET}  $id | $title"
        elif [[ "$id" == "$(state_get_current)" ]]; then
            echo -e "  ${CLR_YELLOW}[curr]${CLR_RESET}  $id | $title"
        else
            echo -e "  ${CLR_DIM}[    ]${CLR_RESET}  $id | $title"
        fi
    done < <(stories_list_details)

    echo ""
}

# ── Subcommand: learnings ──────────────────────────────────────────────────
cmd_learnings() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/learnings.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    local topic="${1:-}"
    learnings_show "$topic"
}

# ── Subcommand: reset ──────────────────────────────────────────────────────
cmd_reset() {
    source "${RALPH_DIR}/lib/state.sh"

    if [[ ! -f "$RALPH_STATE_FILE" ]]; then
        log_error "No state file found."
        exit 1
    fi

    echo "This will reset:"
    echo "  - Completed stories list"
    echo "  - Current story tracking"
    echo "  - Retry count"
    echo ""
    read -rp "Are you sure? [y/N] " confirm
    [[ "$confirm" != [yY] ]] && exit 0

    _state_write_empty
    log_success "State reset."
}

# ── Subcommand: hitl ───────────────────────────────────────────────────────
cmd_hitl() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"
    source "${RALPH_DIR}/lib/specs.sh"
    source "${RALPH_DIR}/lib/hitl.sh"

    prereqs_check_project || exit 1
    config_load || exit 1
    state_init

    local output_path
    output_path=$(config_get '.hitl.output_path' 'docs/hitl-review.html')
    local subcommand="${1:-generate}"

    case "$subcommand" in
        generate)
            [[ "${2:-}" == "--output" && -n "${3:-}" ]] && output_path="$3"
            hitl_generate_report "$output_path"
            ;;
        feedback)
            local feedback_input="${2:?Usage: ralph hitl feedback <hitl-evaluation.json>}"
            hitl_generate_feedback_prd "$feedback_input"
            ;;
        *)
            echo "Usage: ralph hitl [generate|feedback] [options]"
            echo ""
            echo "Subcommands:"
            echo "  generate [--output PATH]     Generate HITL review page (default: docs/hitl-review.html)"
            echo "  feedback <evaluation.json>   Generate remediation PRD from exported HITL evaluation"
            exit 1
            ;;
    esac
}

# ── Subcommand: decompose ──────────────────────────────────────────────────
cmd_decompose() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"
    source "${RALPH_DIR}/lib/specs.sh"
    source "${RALPH_DIR}/lib/prompt.sh"
    source "${RALPH_DIR}/lib/signals.sh"
    source "${RALPH_DIR}/lib/decompose.sh"
    [[ -f "${RALPH_DIR}/lib/learnings.sh" ]] && source "${RALPH_DIR}/lib/learnings.sh"

    prereqs_check || exit 1
    prereqs_check_project || exit 1
    config_load || exit 1
    state_init

    local story_id="${1:?Usage: ralph decompose <story-id>}"

    # Find spec file
    local spec_path
    if ! spec_path=$(spec_find "$story_id"); then
        log_error "Could not find spec for story $story_id"
        exit 1
    fi

    log_info "Manual decomposition of story $story_id"
    if decompose_story "$story_id" "$spec_path" "manual"; then
        log_success "Decomposition complete. Sub-stories added to stories.txt."
        log_info "Run 'ralph stories' to see the updated queue."
    else
        log_error "Decomposition failed for story $story_id"
        exit 1
    fi
}

# ── Subcommand: reconcile ──────────────────────────────────────────────────
cmd_reconcile() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"
    source "${RALPH_DIR}/lib/specs.sh"
    source "${RALPH_DIR}/lib/reconcile.sh"

    prereqs_check_project || exit 1
    config_load || exit 1
    state_init

    ralph_reconcile "$@"
}

# ── Subcommand: verify ────────────────────────────────────────────────────
cmd_verify() {
    source "${RALPH_DIR}/lib/config.sh"
    source "${RALPH_DIR}/lib/state.sh"
    source "${RALPH_DIR}/lib/stories.sh"
    source "${RALPH_DIR}/lib/provenance.sh"

    prereqs_check_project || exit 1
    config_load || exit 1

    box_header "PROVENANCE VERIFICATION"
    provenance_verify

    if [[ "${1:-}" == "--list" ]]; then
        provenance_list
    fi
}

# ── Dispatch ────────────────────────────────────────────────────────────────
case "${1:-}" in
    init)      shift; cmd_init "$@" ;;
    run)       shift; cmd_run "$@" ;;
    decompose) shift; cmd_decompose "$@" ;;
    hitl)      shift; cmd_hitl "$@" ;;
    verify)    shift; cmd_verify "$@" ;;
    reconcile) shift; cmd_reconcile "$@" ;;
    status)    shift; cmd_status "$@" ;;
    stats)     shift; cmd_stats "$@" ;;
    stories)   shift; cmd_stories "$@" ;;
    learnings) shift; cmd_learnings "$@" ;;
    reset)     shift; cmd_reset "$@" ;;
    version|-V|--version) echo "Ralphetamine v${RALPH_VERSION}" ;;
    help|-h|--help|"") usage ;;
    *)
        log_error "Unknown command: $1"
        usage
        ;;
esac
